# RAPPORT TECHNIQUE - ERREURS D'IMPORT EXCEL

**Date**: 2025-01-XX  
**Auteur**: Analyse technique automatique  
**Fichier source**: Erreurs d'import rapport√©es par l'utilisateur

---

## üìã R√âSUM√â EX√âCUTIF

Deux erreurs critiques emp√™chent l'import de fichiers Excel :

1. **Erreur PostgreSQL `AmbiguousParameter`** dans `get_table()` : PostgreSQL ne peut pas d√©terminer le type d'un param√®tre NULL dans une condition SQL.
2. **Erreur PostgreSQL `AmbiguousParameter`** dans `_upsert_employees()` : Conflit de types entre TEXT et VARCHAR lors de l'insertion dans `core.employees`.

---

## üî¥ PROBL√àME #1 : Erreur `AmbiguousParameter` dans `get_table()`

### Description
```
psycopg.errors.AmbiguousParameter: n'a pas pu d√©terminer le type de donn√©es du param√®tre $1
LINE 11: AND ($1 IS NULL OR t.pay_date = $1::date)
```

### Fichier concern√©
- **Fichier**: `app/providers/postgres_provider.py`
- **M√©thode**: `get_table()`
- **Lignes**: 563, 576

### Cause racine
Quand `pay_date` est `None`, PostgreSQL ne peut pas d√©terminer le type du param√®tre `$1` car il est utilis√© dans deux contextes diff√©rents :
1. `%(pay_date)s IS NULL` ‚Üí type ind√©termin√©
2. `t.pay_date = %(pay_date)s::date` ‚Üí type DATE attendu

PostgreSQL ne peut pas d√©duire un type unique pour le param√®tre.

### Code probl√©matique
```python
# Ligne 563
AND (%(pay_date)s IS NULL OR t.pay_date = %(pay_date)s::date)
```

### Solution propos√©e

**Option 1 : Utiliser une condition SQL conditionnelle (recommand√©e)**

Modifier la requ√™te pour s√©parer les conditions :

```python
# Dans app/providers/postgres_provider.py, m√©thode get_table()

# Remplacer les lignes 552-568 par :
sql = """
SELECT 
    e.matricule_norm,
    e.nom_complet AS nom,
    t.pay_date::text AS date_paie,
    t.pay_code AS categorie,
    t.amount_cents / 100.0 AS montant
FROM payroll.payroll_transactions t
JOIN core.employees e ON t.employee_id = e.employee_id
WHERE 1=1
"""

# Construire la clause WHERE conditionnellement
where_clauses = []
params = {
    "matricule": matricule_filter,
    "categorie": categorie_filter,
    "limit": limit,
    "offset": offset,
}

if pay_date_normalized:
    sql += " AND t.pay_date = %(pay_date)s::date"
    params["pay_date"] = pay_date_normalized

if matricule_filter:
    sql += " AND e.matricule_norm = %(matricule)s"

if categorie_filter:
    sql += " AND t.pay_code ILIKE '%%' || %(categorie)s || '%%'"

sql += """
ORDER BY t.pay_date DESC, e.matricule_norm
LIMIT %(limit)s OFFSET %(offset)s
"""

# M√™me logique pour sql_count (lignes 571-579)
sql_count = """
SELECT COUNT(*) AS total
FROM payroll.payroll_transactions t
JOIN core.employees e ON t.employee_id = e.employee_id
WHERE 1=1
"""

if pay_date_normalized:
    sql_count += " AND t.pay_date = %(pay_date)s::date"

if matricule_filter:
    sql_count += " AND e.matricule_norm = %(matricule)s"

if categorie_filter:
    sql_count += " AND t.pay_code ILIKE '%%' || %(categorie)s || '%%'"
```

**Option 2 : Utiliser CAST explicite pour NULL**

```python
# Alternative : utiliser CAST pour forcer le type
sql = """
SELECT 
    e.matricule_norm,
    e.nom_complet AS nom,
    t.pay_date::text AS date_paie,
    t.pay_code AS categorie,
    t.amount_cents / 100.0 AS montant
FROM payroll.payroll_transactions t
JOIN core.employees e ON t.employee_id = e.employee_id
WHERE 1=1
    AND (%(pay_date)s::text IS NULL OR t.pay_date = %(pay_date)s::date)
    AND (%(matricule)s = '' OR e.matricule_norm = %(matricule)s)
    AND (%(categorie)s = '' OR t.pay_code ILIKE '%%' || %(categorie)s || '%%')
ORDER BY t.pay_date DESC, e.matricule_norm
LIMIT %(limit)s OFFSET %(offset)s
"""

# Et modifier params pour toujours passer une cha√Æne
params = {
    "pay_date": pay_date_normalized if pay_date_normalized else None,
    "matricule": matricule_filter,
    "categorie": categorie_filter,
    "limit": limit,
    "offset": offset,
}
```

**Recommandation**: Utiliser l'**Option 1** car elle est plus claire, plus performante (√©vite les conditions inutiles) et √©vite les probl√®mes de typage.

---

## üî¥ PROBL√àME #2 : Erreur `AmbiguousParameter` dans `_upsert_employees()`

### Description
```
psycopg.errors.AmbiguousParameter: types incoh√©rents d√©duit pour le param√®tre $6
LINE 7: $1, $2, $3, $4, $5, $6,
DETAIL: text versus character varying
```

### Fichier concern√©
- **Fichier**: `app/services/import_service_complete.py`
- **M√©thode**: `_upsert_employees()`
- **Lignes**: 1250-1287

### Cause racine

**Probl√®me 1 : Colonnes inexistantes dans le sch√©ma**

D'apr√®s le sch√©ma `app/migration/01_ddl_referentiel.sql`, la table `core.employees` a la structure suivante :

```sql
CREATE TABLE core.employees (
    employee_id         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_key        VARCHAR(255) NOT NULL UNIQUE,
    matricule_norm      VARCHAR(50),
    matricule_raw       VARCHAR(100),
    nom_norm            VARCHAR(255) NOT NULL,
    prenom_norm         VARCHAR(255),
    nom_complet         VARCHAR(500),
    statut              VARCHAR(20) DEFAULT 'actif',
    -- ... m√©tadonn√©es
);
```

**Les colonnes `matricule`, `nom`, et `prenom` n'existent PAS dans ce sch√©ma !**

Le code essaie d'ins√©rer dans :
- `matricule` ‚Üí n'existe pas (devrait √™tre `matricule_norm` ou `matricule_raw`)
- `nom` ‚Üí n'existe pas (devrait √™tre `nom_norm`)
- `prenom` ‚Üí n'existe pas (devrait √™tre `prenom_norm`)

**Probl√®me 2 : Conflit de types TEXT vs VARCHAR**

M√™me si ces colonnes existent dans la base de donn√©es r√©elle (ajout√©es ult√©rieurement), il y a un conflit de types :
- Le code Python passe des valeurs de type `str` (TEXT en Python)
- PostgreSQL attend peut-√™tre VARCHAR avec une longueur sp√©cifique
- Le param√®tre `$6` (probablement `nom` ou `prenom`) a un type ambigu

**Probl√®me 3 : ON CONFLICT sur une colonne inexistante**

Le code utilise `ON CONFLICT (matricule)`, mais :
- Si `matricule` n'existe pas ‚Üí erreur
- Si `matricule` existe mais n'a pas de contrainte UNIQUE ‚Üí erreur
- La contrainte UNIQUE est sur `employee_key`, pas sur `matricule`

### Code probl√©matique
```python
# Lignes 1250-1271
sql = """
INSERT INTO core.employees (
    matricule, nom, prenom, nom_norm, prenom_norm, nom_complet, 
    employee_key, matricule_norm, matricule_raw, statut
)
VALUES (
    %(matricule)s, %(nom)s, %(prenom)s, %(nom_norm)s, %(prenom_norm)s, %(nom_complet)s,
    core.compute_employee_key(%(matricule)s, %(nom_complet)s),
    %(matricule_norm)s,
    %(matricule_raw)s,
    'actif'
)
ON CONFLICT (matricule) DO UPDATE SET
    nom = EXCLUDED.nom,
    prenom = EXCLUDED.prenom,
    nom_norm = EXCLUDED.nom_norm,
    prenom_norm = EXCLUDED.prenom_norm,
    nom_complet = EXCLUDED.nom_complet,
    matricule_norm = EXCLUDED.matricule_norm,
    matricule_raw = EXCLUDED.matricule_raw,
    updated_at = CURRENT_TIMESTAMP
RETURNING employee_id::text
"""
```

### Solution propos√©e

**Option 1 : Utiliser le sch√©ma standard (recommand√©e)**

Corriger la requ√™te pour utiliser uniquement les colonnes qui existent dans le sch√©ma standard :

```python
# Dans app/services/import_service_complete.py, m√©thode _upsert_employees()

# Remplacer les lignes 1250-1271 par :
sql = """
INSERT INTO core.employees (
    employee_key, matricule_norm, matricule_raw,
    nom_norm, prenom_norm, nom_complet, statut
)
VALUES (
    core.compute_employee_key(%(matricule)s, %(nom_complet)s),
    %(matricule_norm)s,
    %(matricule_raw)s,
    %(nom_norm)s,
    %(prenom_norm)s,
    %(nom_complet)s,
    'actif'
)
ON CONFLICT (employee_key) DO UPDATE SET
    nom_norm = EXCLUDED.nom_norm,
    prenom_norm = EXCLUDED.prenom_norm,
    nom_complet = EXCLUDED.nom_complet,
    matricule_norm = EXCLUDED.matricule_norm,
    matricule_raw = EXCLUDED.matricule_raw,
    updated_at = CURRENT_TIMESTAMP
RETURNING employee_id::text
"""
```

**Option 2 : V√©rifier le sch√©ma r√©el et adapter**

Si la colonne `matricule` existe r√©ellement dans la base de donn√©es (ajout√©e via une migration non document√©e), il faut :

1. **V√©rifier le sch√©ma r√©el** :
```sql
SELECT column_name, data_type, character_maximum_length
FROM information_schema.columns
WHERE table_schema = 'core' AND table_name = 'employees'
ORDER BY ordinal_position;
```

2. **Adapter la requ√™te selon le sch√©ma r√©el** :
   - Si `matricule` existe avec UNIQUE ‚Üí utiliser `ON CONFLICT (matricule)`
   - Si `matricule` existe sans UNIQUE ‚Üí utiliser `ON CONFLICT (employee_key)` et ins√©rer aussi `matricule`
   - Si `matricule` n'existe pas ‚Üí utiliser Option 1

3. **Forcer les types explicites** :
```python
sql = """
INSERT INTO core.employees (
    matricule, nom, prenom, nom_norm, prenom_norm, nom_complet, 
    employee_key, matricule_norm, matricule_raw, statut
)
VALUES (
    %(matricule)s::VARCHAR(100),
    %(nom)s::VARCHAR(255),
    %(prenom)s::VARCHAR(255),
    %(nom_norm)s::VARCHAR(255),
    %(prenom_norm)s::VARCHAR(255),
    %(nom_complet)s::VARCHAR(500),
    core.compute_employee_key(%(matricule)s, %(nom_complet)s),
    %(matricule_norm)s::VARCHAR(50),
    %(matricule_raw)s::VARCHAR(100),
    'actif'
)
ON CONFLICT (matricule) DO UPDATE SET
    nom = EXCLUDED.nom,
    prenom = EXCLUDED.prenom,
    nom_norm = EXCLUDED.nom_norm,
    prenom_norm = EXCLUDED.prenom_norm,
    nom_complet = EXCLUDED.nom_complet,
    matricule_norm = EXCLUDED.matricule_norm,
    matricule_raw = EXCLUDED.matricule_raw,
    updated_at = CURRENT_TIMESTAMP
RETURNING employee_id::text
"""
```

**Recommandation**: Utiliser l'**Option 1** car elle respecte le sch√©ma document√©. Si la base de donn√©es r√©elle a des colonnes suppl√©mentaires, cr√©er une migration pour les documenter.

---

## üìù FICHIERS √Ä MODIFIER

### 1. `app/providers/postgres_provider.py`

**M√©thode**: `get_table()`  
**Lignes**: 540-592  
**Modification**: Remplacer la construction de la requ√™te SQL pour √©viter les param√®tres NULL dans les conditions.

### 2. `app/services/import_service_complete.py`

**M√©thode**: `_upsert_employees()`  
**Lignes**: 1250-1287  
**Modification**: Corriger la requ√™te INSERT pour utiliser uniquement les colonnes existantes dans le sch√©ma standard (`employee_key`, `matricule_norm`, `matricule_raw`, `nom_norm`, `prenom_norm`, `nom_complet`).

---

## ‚úÖ VALIDATION

Apr√®s correction, v√©rifier :

1. **Test 1** : Import d'un fichier Excel avec `pay_date` = None
   - V√©rifier que `get_table()` fonctionne sans erreur
   - V√©rifier que toutes les transactions sont retourn√©es

2. **Test 2** : Import d'un fichier Excel avec `pay_date` = "2025-08-28"
   - V√©rifier que `get_table()` filtre correctement par date
   - V√©rifier que seules les transactions de cette date sont retourn√©es

3. **Test 3** : Import d'un fichier Excel avec des employ√©s
   - V√©rifier que `_upsert_employees()` ins√®re correctement dans `core.employees`
   - V√©rifier que les employ√©s existants sont mis √† jour (ON CONFLICT)
   - V√©rifier que `employee_key` est calcul√© correctement

4. **Test 4** : V√©rifier le sch√©ma r√©el de `core.employees`
   ```sql
   SELECT column_name, data_type, character_maximum_length, is_nullable
   FROM information_schema.columns
   WHERE table_schema = 'core' AND table_name = 'employees'
   ORDER BY ordinal_position;
   ```

---

## üîç ANALYSE COMPL√âMENTAIRE

### V√©rification du sch√©ma r√©el

Avant d'appliquer les corrections, il est recommand√© de v√©rifier le sch√©ma r√©el de la base de donn√©es :

```sql
-- V√©rifier les colonnes de core.employees
SELECT 
    column_name, 
    data_type, 
    character_maximum_length,
    is_nullable,
    column_default
FROM information_schema.columns
WHERE table_schema = 'core' 
  AND table_name = 'employees'
ORDER BY ordinal_position;

-- V√©rifier les contraintes UNIQUE
SELECT 
    tc.constraint_name,
    kcu.column_name
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
WHERE tc.table_schema = 'core'
  AND tc.table_name = 'employees'
  AND tc.constraint_type = 'UNIQUE';
```

### Migration possible n√©cessaire

Si la colonne `matricule` existe r√©ellement dans la base de donn√©es mais n'est pas document√©e, cr√©er une migration pour l'ajouter au sch√©ma standard :

```sql
-- Migration: Ajouter colonne matricule si elle n'existe pas
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = 'core' 
          AND table_name = 'employees' 
          AND column_name = 'matricule'
    ) THEN
        ALTER TABLE core.employees 
        ADD COLUMN matricule VARCHAR(100);
        
        -- Cr√©er index unique si n√©cessaire
        CREATE UNIQUE INDEX IF NOT EXISTS idx_employees_matricule_unique
        ON core.employees(matricule)
        WHERE matricule IS NOT NULL;
    END IF;
END $$;
```

---

## üìå NOTES IMPORTANTES

1. **Coh√©rence du sch√©ma** : Le code doit √™tre align√© avec le sch√©ma r√©el de la base de donn√©es. Si des colonnes suppl√©mentaires existent, elles doivent √™tre document√©es dans les migrations.

2. **Performance** : L'Option 1 pour `get_table()` am√©liore les performances en √©vitant les conditions SQL inutiles quand les filtres sont vides.

3. **Compatibilit√©** : Les corrections propos√©es respectent le sch√©ma standard document√© dans `app/migration/01_ddl_referentiel.sql`.

4. **Tests** : Apr√®s correction, ex√©cuter tous les tests d'int√©gration pour valider que l'import fonctionne correctement.

---

## üéØ PRIORIT√â

- **Probl√®me #1** : üî¥ **CRITIQUE** - Bloque l'affichage des donn√©es dans l'UI
- **Probl√®me #2** : üî¥ **CRITIQUE** - Bloque l'import de fichiers Excel

Les deux probl√®mes doivent √™tre corrig√©s pour que l'import fonctionne.

---

**Fin du rapport**

