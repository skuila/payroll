-- ============================================================================
-- DDL: Référentiel Employés - Architecture Dimension/Fait
-- PostgreSQL 17 - Utilisation IDENTITY au lieu de SERIAL
-- Version: 1.0
-- Date: 2025-10-16
-- ============================================================================

-- Configuration
SET client_min_messages TO WARNING;
SET search_path TO payroll, core, reference, public;

-- Créer schéma core
CREATE SCHEMA IF NOT EXISTS core;
GRANT USAGE ON SCHEMA core TO payroll_app;
GRANT CREATE ON SCHEMA core TO payroll_app;

-- ============================================================================
-- FONCTION: Normalisation employee_key
-- ============================================================================

CREATE OR REPLACE FUNCTION core.compute_employee_key(
    p_matricule TEXT,
    p_nom TEXT
) RETURNS VARCHAR(255) AS $$
DECLARE
    v_matricule_clean TEXT;
    v_nom_norm TEXT;
BEGIN
    -- Nettoyer matricule (trim + retrait parasites)
    v_matricule_clean := NULLIF(
        BTRIM(regexp_replace(COALESCE(p_matricule, ''), '[^0-9A-Za-z\-]', '', 'g')),
        ''
    );
    
    -- Si matricule numérique → retirer zéros en tête
    IF v_matricule_clean IS NOT NULL AND v_matricule_clean ~ '^[0-9]+$' THEN
        v_matricule_clean := NULLIF(
            regexp_replace(v_matricule_clean, '^0+', ''),
            ''
        );
    END IF;
    
    -- Si matricule valide → retourner
    IF v_matricule_clean IS NOT NULL THEN
        RETURN v_matricule_clean;
    END IF;
    
    -- Sinon fallback sur nom normalisé (hashé)
    v_nom_norm := regexp_replace(
        unaccent(LOWER(COALESCE(p_nom, ''))),
        '\s+', ' ', 'g'
    );
    
    RETURN MD5(v_nom_norm);
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

COMMENT ON FUNCTION core.compute_employee_key IS 
    'Calcule employee_key: matricule normalisé (trim, parasites, zéros) ou MD5(nom normalisé)';

-- ============================================================================
-- TABLE: core.employees (Dimension Employés)
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.employees (
    -- Clés
    employee_id         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_key        VARCHAR(255) NOT NULL UNIQUE,
    
    -- Identifiants
    matricule_norm      VARCHAR(50),
    matricule_raw       VARCHAR(100),
    
    -- Informations personnelles (normalisées)
    nom_norm            VARCHAR(255) NOT NULL,
    prenom_norm         VARCHAR(255),
    nom_complet         VARCHAR(500),
    
    -- Statut
    statut              VARCHAR(20) DEFAULT 'actif' 
        CHECK (statut IN ('actif', 'inactif', 'suspendu')),
    
    -- Métadonnées
    source_system       VARCHAR(50) DEFAULT 'excel_import',
    created_at          TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at          TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    created_by          VARCHAR(100) DEFAULT CURRENT_USER,
    updated_by          VARCHAR(100) DEFAULT CURRENT_USER
);

-- Index
CREATE UNIQUE INDEX idx_employees_key ON core.employees(employee_key);
CREATE INDEX idx_employees_matricule ON core.employees(matricule_norm) 
    WHERE matricule_norm IS NOT NULL;
CREATE INDEX idx_employees_statut ON core.employees(statut);
CREATE INDEX idx_employees_nom ON core.employees(nom_norm, prenom_norm);

-- Trigger pour updated_at
CREATE OR REPLACE FUNCTION core.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    NEW.updated_by = CURRENT_USER;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_employees_updated_at
    BEFORE UPDATE ON core.employees
    FOR EACH ROW
    EXECUTE FUNCTION core.update_updated_at_column();

-- Commentaires
COMMENT ON TABLE core.employees IS 'Référentiel unique employés (dimension)';
COMMENT ON COLUMN core.employees.employee_id IS 'Clé technique IDENTITY';
COMMENT ON COLUMN core.employees.employee_key IS 'Clé métier normalisée (unique)';
COMMENT ON COLUMN core.employees.matricule_norm IS 'Matricule normalisé (trim, zéros, parasites)';
COMMENT ON COLUMN core.employees.statut IS 'actif | inactif | suspendu';

-- ============================================================================
-- TABLE: payroll.import_batches (Traçabilité)
-- ============================================================================

CREATE TABLE IF NOT EXISTS payroll.import_batches (
    batch_id            INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    batch_uuid          UUID DEFAULT gen_random_uuid() UNIQUE,
    filename            VARCHAR(500),
    file_checksum       VARCHAR(64),
    total_rows          INTEGER,
    valid_rows          INTEGER,
    invalid_rows        INTEGER,
    new_employees       INTEGER,
    new_transactions    INTEGER,
    status              VARCHAR(20) DEFAULT 'pending'
        CHECK (status IN ('pending', 'processing', 'completed', 'failed', 'rolled_back')),
    error_message       TEXT,
    started_at          TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    completed_at        TIMESTAMPTZ,
    created_by          VARCHAR(100) DEFAULT CURRENT_USER
);

CREATE INDEX idx_batches_status ON payroll.import_batches(status);
CREATE INDEX idx_batches_started ON payroll.import_batches(started_at DESC);

COMMENT ON TABLE payroll.import_batches IS 'Historique imports (audit/traçabilité)';

-- ============================================================================
-- TABLE: payroll.stg_imported_payroll (Staging)
-- ============================================================================

CREATE TABLE IF NOT EXISTS payroll.stg_imported_payroll (
    -- ID staging
    stg_id              INTEGER GENERATED BY DEFAULT AS IDENTITY,
    
    -- Données brutes
    matricule_raw       VARCHAR(100),
    employe_raw         VARCHAR(500),
    date_paie_raw       VARCHAR(50),
    categorie_paie_raw  VARCHAR(200),
    montant_raw         VARCHAR(50),
    
    -- Données normalisées
    matricule_clean     VARCHAR(50),
    nom_norm            VARCHAR(255),
    prenom_norm         VARCHAR(255),
    employee_key        VARCHAR(255),
    pay_date            DATE,
    pay_code            VARCHAR(50),
    amount_cents        BIGINT,
    
    -- Validation
    is_valid            BOOLEAN DEFAULT TRUE,
    validation_errors   TEXT[],
    
    -- Traçabilité
    import_batch_id     INTEGER,
    source_row_no       INTEGER,
    created_at          TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_stg_employee_key ON payroll.stg_imported_payroll(employee_key);
CREATE INDEX idx_stg_batch ON payroll.stg_imported_payroll(import_batch_id);
CREATE INDEX idx_stg_valid ON payroll.stg_imported_payroll(is_valid);

COMMENT ON TABLE payroll.stg_imported_payroll IS 'Staging import (temporaire, nettoyé après validation)';

-- ============================================================================
-- TABLE: payroll.payroll_transactions (Fait Paie - Partitionné)
-- ============================================================================

CREATE TABLE IF NOT EXISTS payroll.payroll_transactions (
    -- Clés
    transaction_id      BIGINT GENERATED BY DEFAULT AS IDENTITY,
    employee_id         INTEGER NOT NULL,
    
    -- Période de paie
    pay_date            DATE NOT NULL,
    pay_day             INTEGER GENERATED ALWAYS AS (EXTRACT(DAY FROM pay_date)) STORED,
    pay_month           INTEGER GENERATED ALWAYS AS (EXTRACT(MONTH FROM pay_date)) STORED,
    pay_year            INTEGER GENERATED ALWAYS AS (EXTRACT(YEAR FROM pay_date)) STORED,
    period_seq_in_year  INTEGER,
    
    -- Détails paie
    pay_code            VARCHAR(50) NOT NULL,
    amount_cents        BIGINT NOT NULL CHECK (amount_cents <> 0),
    
    -- Traçabilité import
    import_batch_id     INTEGER,
    source_file         VARCHAR(500),
    source_row_no       INTEGER,
    
    -- Métadonnées
    created_at          TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    created_by          VARCHAR(100) DEFAULT CURRENT_USER,
    
    -- Contraintes
    CONSTRAINT pk_payroll_transactions PRIMARY KEY (transaction_id, pay_date),
    CONSTRAINT fk_employee 
        FOREIGN KEY (employee_id) 
        REFERENCES core.employees(employee_id)
        ON DELETE RESTRICT,
    CONSTRAINT fk_import_batch 
        FOREIGN KEY (import_batch_id) 
        REFERENCES payroll.import_batches(batch_id)
        ON DELETE SET NULL
) PARTITION BY RANGE (pay_date);

-- Index sur table partitionnée
CREATE INDEX idx_payroll_employee ON payroll.payroll_transactions(employee_id);
CREATE INDEX idx_payroll_date ON payroll.payroll_transactions(pay_date);
CREATE INDEX idx_payroll_period ON payroll.payroll_transactions(pay_year, pay_month);
CREATE INDEX idx_payroll_employee_date ON payroll.payroll_transactions(employee_id, pay_date);
CREATE INDEX idx_payroll_code ON payroll.payroll_transactions(pay_code);

COMMENT ON TABLE payroll.payroll_transactions IS 'Fait paie (partitionné par année sur pay_date)';
COMMENT ON COLUMN payroll.payroll_transactions.amount_cents IS 'Montant en cents (précision, évite arrondis)';
COMMENT ON CONSTRAINT chk_amount_cents ON payroll.payroll_transactions IS 'Pas de montants à 0';

-- ============================================================================
-- PARTITIONS: Années 2024, 2025, 2026
-- ============================================================================

-- Partition 2024
CREATE TABLE IF NOT EXISTS payroll.payroll_transactions_2024
    PARTITION OF payroll.payroll_transactions
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

COMMENT ON TABLE payroll.payroll_transactions_2024 IS 'Partition année 2024';

-- Partition 2025
CREATE TABLE IF NOT EXISTS payroll.payroll_transactions_2025
    PARTITION OF payroll.payroll_transactions
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

COMMENT ON TABLE payroll.payroll_transactions_2025 IS 'Partition année 2025';

-- Partition 2026
CREATE TABLE IF NOT EXISTS payroll.payroll_transactions_2026
    PARTITION OF payroll.payroll_transactions
    FOR VALUES FROM ('2026-01-01') TO ('2027-01-01');

COMMENT ON TABLE payroll.payroll_transactions_2026 IS 'Partition année 2026';

-- ============================================================================
-- MODÈLE: Créer partition pour nouvelle année
-- ============================================================================

-- Pour créer partition 2027:
-- CREATE TABLE payroll.payroll_transactions_2027
--     PARTITION OF payroll.payroll_transactions
--     FOR VALUES FROM ('2027-01-01') TO ('2028-01-01');

-- ============================================================================
-- TABLE: reference.pay_codes (Référentiel codes paie)
-- ============================================================================

CREATE TABLE IF NOT EXISTS reference.pay_codes (
    pay_code_id         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pay_code            VARCHAR(50) NOT NULL UNIQUE,
    pay_code_desc       VARCHAR(255),
    pay_code_type       VARCHAR(20)
        CHECK (pay_code_type IN ('earning', 'deduction', 'tax', 'benefit', 'other')),
    is_active           BOOLEAN DEFAULT TRUE,
    created_at          TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_pay_codes_type ON reference.pay_codes(pay_code_type);
CREATE INDEX idx_pay_codes_active ON reference.pay_codes(is_active);

COMMENT ON TABLE reference.pay_codes IS 'Référentiel codes de paie';

-- Seed minimal
INSERT INTO reference.pay_codes (pay_code, pay_code_desc, pay_code_type)
VALUES 
    ('NON_SPECIFIE', 'Non spécifié', 'other'),
    ('SALAIRE_BASE', 'Salaire de base', 'earning'),
    ('HEURES_SUPP', 'Heures supplémentaires', 'earning'),
    ('PRIME', 'Prime', 'earning'),
    ('IMPOT', 'Impôts', 'tax'),
    ('COTISATION', 'Cotisations sociales', 'deduction'),
    ('ASSURANCE', 'Assurance employeur', 'benefit')
ON CONFLICT (pay_code) DO NOTHING;

-- ============================================================================
-- VUE: Compatibilité (transition)
-- ============================================================================

CREATE OR REPLACE VIEW payroll.v_imported_payroll_compat AS
SELECT
    e.matricule_raw AS "matricule ",
    e.nom_complet AS "employé ",
    t.pay_date AS "date de paie ",
    t.pay_code AS "categorie de paie ",
    t.amount_cents / 100.0 AS "montant ",
    t.employee_id,
    t.transaction_id
FROM payroll.payroll_transactions t
JOIN core.employees e ON t.employee_id = e.employee_id;

COMMENT ON VIEW payroll.v_imported_payroll_compat IS 
    'Vue compatibilité old-style (transition)';

-- ============================================================================
-- VUE: Employés enrichis
-- ============================================================================

CREATE OR REPLACE VIEW core.v_employees_enriched AS
SELECT
    e.*,
    COUNT(DISTINCT t.pay_date) AS nb_moiss_paie,
    MIN(t.pay_date) AS premiere_paie,
    MAX(t.pay_date) AS derniere_paie,
    SUM(t.amount_cents) / 100.0 AS total_paie_lifetime
FROM core.employees e
LEFT JOIN payroll.payroll_transactions t ON e.employee_id = t.employee_id
GROUP BY e.employee_id;

COMMENT ON VIEW core.v_employees_enriched IS 
    'Employés avec stats paie agrégées';

-- ============================================================================
-- GRANTS
-- ============================================================================

-- core.employees
GRANT SELECT, INSERT, UPDATE ON core.employees TO payroll_app;

-- payroll.payroll_transactions (et partitions)
GRANT SELECT, INSERT ON payroll.payroll_transactions TO payroll_app;
GRANT SELECT, INSERT ON payroll.payroll_transactions_2024 TO payroll_app;
GRANT SELECT, INSERT ON payroll.payroll_transactions_2025 TO payroll_app;
GRANT SELECT, INSERT ON payroll.payroll_transactions_2026 TO payroll_app;

-- payroll.import_batches
GRANT SELECT, INSERT, UPDATE ON payroll.import_batches TO payroll_app;

-- payroll.stg_imported_payroll
GRANT ALL ON payroll.stg_imported_payroll TO payroll_app;

-- reference.pay_codes
GRANT SELECT, INSERT ON reference.pay_codes TO payroll_app;

-- Vues
GRANT SELECT ON payroll.v_imported_payroll_compat TO payroll_app;
GRANT SELECT ON core.v_employees_enriched TO payroll_app;

-- Fonctions
GRANT EXECUTE ON FUNCTION core.compute_employee_key TO payroll_app;
GRANT EXECUTE ON FUNCTION core.update_updated_at_column TO payroll_app;

-- ============================================================================
-- FIN DDL
-- ============================================================================

\echo '✓ DDL exécuté avec succès'
\echo '  Tables créées:'
\echo '    - core.employees'
\echo '    - payroll.payroll_transactions (partitions 2024-2026)'
\echo '    - payroll.import_batches'
\echo '    - payroll.stg_imported_payroll'
\echo '    - reference.pay_codes (avec seed)'
\echo '  Vues créées:'
\echo '    - payroll.v_imported_payroll_compat'
\echo '    - core.v_employees_enriched'
\echo '  Fonctions créées:'
\echo '    - core.compute_employee_key()'
\echo '    - core.update_updated_at_column()'

