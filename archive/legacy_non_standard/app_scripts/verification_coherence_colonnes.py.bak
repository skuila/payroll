#!/usr/bin/env python3
"""
Script de v√©rification int√©grale de la coh√©rence des noms de colonnes
entre l'application, la base de donn√©es et les KPI/API
"""

import psycopg
import os
from pathlib import Path
import re
import sys

# Connexion ‚Äî construit √† partir des variables d'environnement pour √©viter les secrets en clair
DSN = (
    os.getenv("DATABASE_URL")
    or os.getenv("PAYROLL_DSN")
    or (
        f"postgresql://{os.getenv('PAYROLL_DB_USER','payroll_app')}:"
        f"{os.getenv('PAYROLL_DB_PASSWORD','__SET_AT_DEPLOY__')}@"
        f"{os.getenv('PAYROLL_DB_HOST','localhost')}:{os.getenv('PAYROLL_DB_PORT','5432')}/"
        f"{os.getenv('PAYROLL_DB_NAME','payroll_db')}"
    )
)

if "__SET_AT_DEPLOY__" in DSN:
    print(
        "WARNING: PAYROLL_DB_PASSWORD non configur√© dans l'environnement ‚Äî v√©rifiez .env ou variables CI"
    )


def get_table_columns(conn, schema, table):
    """R√©cup√®re les colonnes d'une table"""
    with conn.cursor() as cur:
        cur.execute(
            """
            SELECT column_name, data_type 
            FROM information_schema.columns 
            WHERE table_schema = %s AND table_name = %s
            ORDER BY ordinal_position
        """,
            (schema, table),
        )
        return {row[0]: row[1] for row in cur.fetchall()}


def get_view_columns(conn, schema, view):
    """R√©cup√®re les colonnes d'une vue"""
    with conn.cursor() as cur:
        cur.execute(
            """
            SELECT column_name, data_type 
            FROM information_schema.columns 
            WHERE table_schema = %s AND table_name = %s
            ORDER BY ordinal_position
        """,
            (schema, view),
        )
        return {row[0]: row[1] for row in cur.fetchall()}


def extract_sql_column_names(sql_file):
    """Extrait les noms de colonnes utilis√©s dans un fichier SQL"""
    with open(sql_file, "r", encoding="utf-8") as f:
        content = f.read()

    # Extraire les colonnes SELECT
    select_pattern = r"SELECT\s+(.*?)\s+FROM"
    matches = re.findall(select_pattern, content, re.IGNORECASE | re.DOTALL)
    columns = set()
    for match in matches:
        # Extraire les noms apr√®s AS
        as_pattern = r"AS\s+(\w+)"
        columns.update(re.findall(as_pattern, match, re.IGNORECASE))
        # Extraire les colonnes simples avant AS
        simple_pattern = r"\b(\w+)\s*,\s*"
        columns.update(re.findall(simple_pattern, match))

    return columns


def check_coherence():
    """V√©rifie la coh√©rence int√©grale"""
    print("=" * 80)
    print("üîç V√âRIFICATION INT√âGRALE DE COH√âRENCE DES COLONNES")
    print("=" * 80)

    issues = []

    try:
        conn = psycopg.connect(DSN)

        # ====================================================================
        # 1. V√âRIFICATION DES TABLES DE BASE
        # ====================================================================
        print("\nüìã 1. V√©rification des tables de base")
        print("-" * 80)

        # Table core.employees
        if conn:
            emp_cols = get_table_columns(conn, "core", "employees")
            print(f"‚úÖ core.employees: {len(emp_cols)} colonnes trouv√©es")
            expected_emp_cols = [
                "employee_id",
                "employee_key",
                "matricule_norm",
                "nom_norm",
                "prenom_norm",
            ]
            for col in expected_emp_cols:
                if col not in emp_cols:
                    issues.append(f"‚ùå core.employees manque la colonne: {col}")
                    print(f"   ‚ùå Colonne manquante: {col}")
                else:
                    print(f"   ‚úÖ {col}")

            # V√©rifier colonnes utilis√©es dans les vues mais absentes
            view_expected = ["categorie_emploi", "poste_budgetaire"]
            for col in view_expected:
                if col not in emp_cols:
                    issues.append(
                        f"‚ùå CRITIQUE: core.employees n'a pas {col} mais utilis√© dans les vues!"
                    )
                    print(f"   ‚ùå CRITIQUE: {col} manquante (utilis√©e dans les vues)")

        # Table payroll.payroll_transactions
        if conn:
            trans_cols = get_table_columns(conn, "payroll", "payroll_transactions")
            print(
                f"‚úÖ payroll.payroll_transactions: {len(trans_cols)} colonnes trouv√©es"
            )
            expected_trans_cols = [
                "transaction_id",
                "employee_id",
                "pay_date",
                "pay_code",
                "amount_cents",
            ]
            for col in expected_trans_cols:
                if col not in trans_cols:
                    issues.append(f"‚ùå payroll.payroll_transactions manque: {col}")
                    print(f"   ‚ùå Colonne manquante: {col}")
                else:
                    print(f"   ‚úÖ {col}")

        # ====================================================================
        # 2. V√âRIFICATION DES VUES KPI
        # ====================================================================
        print("\nüìä 2. V√©rification des vues KPI")
        print("-" * 80)

        kpi_views = {
            "paie": [
                "v_kpi_periode",
                "v_kpi_par_categorie_emploi",
                "v_kpi_par_code_paie",
                "v_kpi_par_poste_budgetaire",
                "v_kpi_par_employe_periode",
            ]
        }

        view_columns_map = {}
        for schema, views in kpi_views.items():
            for view in views:
                try:
                    if conn:
                        cols = get_view_columns(conn, schema, view)
                        view_columns_map[f"{schema}.{view}"] = cols
                        print(f"‚úÖ {schema}.{view}: {len(cols)} colonnes")

                        # V√©rifier colonnes obligatoires
                        required = [
                            "periode",
                            "date_paie",
                            "gains_brut",
                            "net_a_payer",
                            "nb_employes",
                        ]
                        for req in required:
                            if req not in cols:
                                issues.append(f"‚ùå {schema}.{view} manque: {req}")
                                print(f"   ‚ùå Colonne manquante: {req}")
                            else:
                                print(f"   ‚úÖ {req}")
                except Exception as e:
                    issues.append(f"‚ùå Erreur acc√®s {schema}.{view}: {e}")
                    print(f"   ‚ùå Erreur: {e}")

        # ====================================================================
        # 3. V√âRIFICATION DES INCOH√âRENCES DANS LES VUES SQL
        # ====================================================================
        print("\nüîç 3. V√©rification des incoh√©rences dans les scripts SQL")
        print("-" * 80)

        sql_file = Path(__file__).parent / "admin_create_kpi_views.sql"
        if sql_file.exists():
            with open(sql_file, "r", encoding="utf-8") as f:
                sql_content = f.read()

            # V√©rifier r√©f√©rences √† payroll.employees (devrait √™tre core.employees)
            if "payroll.employees" in sql_content:
                issues.append(
                    "‚ùå CRITIQUE: admin_create_kpi_views.sql r√©f√©rence payroll.employees au lieu de core.employees"
                )
                print(
                    "   ‚ùå CRITIQUE: R√©f√©rence √† payroll.employees trouv√©e (devrait √™tre core.employees)"
                )

            # V√©rifier r√©f√©rences √† e.categorie_emploi
            if "e.categorie_emploi" in sql_content:
                if not conn or "categorie_emploi" not in emp_cols:
                    issues.append(
                        "‚ùå CRITIQUE: Les vues utilisent e.categorie_emploi mais core.employees n'a pas cette colonne"
                    )
                    print(
                        "   ‚ùå CRITIQUE: e.categorie_emploi utilis√© mais colonne absente de core.employees"
                    )

            # V√©rifier r√©f√©rences √† e.poste_budgetaire
            if "e.poste_budgetaire" in sql_content:
                if not conn or "poste_budgetaire" not in emp_cols:
                    issues.append(
                        "‚ùå CRITIQUE: Les vues utilisent e.poste_budgetaire mais core.employees n'a pas cette colonne"
                    )
                    print(
                        "   ‚ùå CRITIQUE: e.poste_budgetaire utilis√© mais colonne absente de core.employees"
                    )

        # ====================================================================
        # 4. V√âRIFICATION DES COLONNES DANS L'API
        # ====================================================================
        print("\nüîå 4. V√©rification des colonnes utilis√©es dans l'API")
        print("-" * 80)

        api_file = Path(__file__).parent.parent / "api" / "routes" / "kpi.py"
        if api_file.exists():
            with open(api_file, "r", encoding="utf-8") as f:
                api_content = f.read()

            # Extraire colonnes utilis√©es dans les requ√™tes
            api_columns = set()

            # Colonnes dans SELECT
            select_pattern = r"SELECT\s+(.*?)\s+FROM"
            for match in re.finditer(
                select_pattern, api_content, re.IGNORECASE | re.DOTALL
            ):
                cols = match.group(1)
                # Extraire apr√®s AS
                for as_match in re.finditer(r"AS\s+(\w+)", cols, re.IGNORECASE):
                    api_columns.add(as_match.group(1))
                # Extraire colonnes simples
                for col_match in re.finditer(r"\b(\w+)\s+as\s+", cols, re.IGNORECASE):
                    api_columns.add(col_match.group(1))

            # Colonnes dans WHERE
            where_pattern = r"WHERE\s+(\w+)\s*="
            for match in re.finditer(where_pattern, api_content, re.IGNORECASE):
                api_columns.add(match.group(1))

            print(f"   Colonnes d√©tect√©es dans l'API: {sorted(api_columns)}")

            # V√©rifier coh√©rence avec les vues
            for view_path, view_cols in view_columns_map.items():
                if "v_kpi_periode" in view_path:
                    # Colonnes API attendues pour v_kpi_periode
                    expected_api_cols = [
                        "periode",
                        "date_paie",
                        "gains_brut",
                        "nb_employes",
                    ]
                    for api_col in expected_api_cols:
                        if api_col not in view_cols:
                            issues.append(
                                f"‚ùå L'API utilise {api_col} mais absent de {view_path}"
                            )
                            print(
                                f"   ‚ùå {api_col} utilis√© par API mais absent de {view_path}"
                            )

            # V√©rifier p√©riode_paie vs periode
            if "periode_paie" in api_content:
                issues.append(
                    "‚ö†Ô∏è API utilise 'periode_paie' mais les vues d√©finissent 'periode'"
                )
                print(
                    "   ‚ö†Ô∏è Attention: API utilise 'periode_paie' mais vues utilisent 'periode'"
                )

        # ====================================================================
        # 5. V√âRIFICATION DES JOINS ERRON√âS
        # ====================================================================
        print("\nüîó 5. V√©rification des JOINs")
        print("-" * 80)

        if sql_file.exists():
            with open(sql_file, "r", encoding="utf-8") as f:
                sql_content = f.read()

            # V√©rifier JOIN avec payroll.employees
            if (
                "LEFT JOIN payroll.employees" in sql_content
                or "JOIN payroll.employees" in sql_content
            ):
                issues.append(
                    "‚ùå CRITIQUE: JOIN avec payroll.employees - devrait √™tre core.employees"
                )
                print(
                    "   ‚ùå CRITIQUE: JOIN utilise payroll.employees au lieu de core.employees"
                )

        # ====================================================================
        # 6. R√âSUM√â DES PROBL√àMES
        # ====================================================================
        print("\n" + "=" * 80)
        print("üìä R√âSUM√â DES PROBL√àMES D√âTECT√âS")
        print("=" * 80)

        if not issues:
            print("‚úÖ Aucun probl√®me d√©tect√© - Tout est coh√©rent!")
        else:
            print(f"‚ö†Ô∏è {len(issues)} probl√®me(s) d√©tect√©(s):\n")
            for i, issue in enumerate(issues, 1):
                print(f"{i}. {issue}")

        if conn:
            conn.close()

        return len(issues) == 0

    except Exception as e:
        print(f"‚ùå Erreur lors de la v√©rification: {e}")
        import traceback

        traceback.print_exc()
        return False


if __name__ == "__main__":
    success = check_coherence()
    sys.exit(0 if success else 1)
